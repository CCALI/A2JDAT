{
  "_args": [
    [
      {
        "raw": "can-zone@https://registry.npmjs.org/can-zone/-/can-zone-0.5.8.tgz",
        "scope": null,
        "escapedName": "can-zone",
        "name": "can-zone",
        "rawSpec": "https://registry.npmjs.org/can-zone/-/can-zone-0.5.8.tgz",
        "spec": "https://registry.npmjs.org/can-zone/-/can-zone-0.5.8.tgz",
        "type": "remote"
      },
      "/Users/tobias/iit/azure/DAT/StandaloneDAT"
    ]
  ],
  "_from": "can-zone@>=0.5.0 <0.6.0",
  "_id": "can-zone@0.5.8",
  "_inCache": true,
  "_location": "/can-zone",
  "_phantomChildren": {},
  "_requested": {
    "raw": "can-zone@https://registry.npmjs.org/can-zone/-/can-zone-0.5.8.tgz",
    "scope": null,
    "escapedName": "can-zone",
    "name": "can-zone",
    "rawSpec": "https://registry.npmjs.org/can-zone/-/can-zone-0.5.8.tgz",
    "spec": "https://registry.npmjs.org/can-zone/-/can-zone-0.5.8.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/",
    "/done-autorender",
    "/done-ssr"
  ],
  "_resolved": "https://registry.npmjs.org/can-zone/-/can-zone-0.5.8.tgz",
  "_shasum": "b904d67464a045ad9ec85137a6d43f98b4655392",
  "_shrinkwrap": null,
  "_spec": "can-zone@https://registry.npmjs.org/can-zone/-/can-zone-0.5.8.tgz",
  "_where": "/Users/tobias/iit/azure/DAT/StandaloneDAT",
  "author": {
    "name": "Bitovi"
  },
  "bit-docs": {
    "dependencies": {
      "bit-docs-glob-finder": "^0.0.5",
      "bit-docs-dev": "^0.0.3",
      "bit-docs-js": "^0.0.3",
      "bit-docs-generate-readme": "^0.0.8"
    },
    "glob": {
      "pattern": "**/*.{js,md}",
      "ignore": "node_modules/**/*"
    },
    "readme": {
      "apis": "./docs/apis.json"
    },
    "parent": "can-view-live"
  },
  "bugs": {
    "url": "https://github.com/canjs/can-zone/issues"
  },
  "dependencies": {},
  "description": "Asynchronous render for all frameworks",
  "devDependencies": {
    "bit-docs": "0.0.7",
    "chai": "^3.4.1",
    "mocha": "^2.3.4",
    "steal": "^0.12.4",
    "steal-mocha": "0.0.3",
    "steal-tools": "^0.16.0",
    "testee": "^0.2.2"
  },
  "homepage": "https://github.com/canjs/can-zone#readme",
  "keywords": [
    "server-side",
    "rendering",
    "canjs",
    "asynchronous",
    "rendering"
  ],
  "license": "MIT",
  "main": "lib/zone.js",
  "name": "can-zone",
  "optionalDependencies": {},
  "readme": "![can-zone-logo](https://cloud.githubusercontent.com/assets/361671/14564599/4249847e-02f5-11e6-8704-13fca28a9426.png)\n\n# can-zone\n\n[![Build Status](https://travis-ci.org/canjs/can-zone.svg?branch=master)](https://travis-ci.org/canjs/can-zone)\n[![npm version](https://badge.fury.io/js/can-zone.svg)](http://badge.fury.io/js/can-zone)\n\nA library that tracks asynchronous activity and lets you know when it has completed. Useful when you need to call a function and wait for all async behavior to complete, such as when performing server-side rendering.\n\n## Install\n\n```\nnpm install can-zone --save\n```\n\n## Usage\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\n\tsetTimeout(function(){\n\t\t\n\t}, 29);\n\n\tsetTimeout(function(){\n\t\t\n\t}, 13);\n\n\tvar xhr = new XMLHttpRequest();\n\txhr.open(\"GET\", \"http://chat.donejs.com/api/messages\");\n\txhr.onload = function(){\n\t\t\n\t};\n\txhr.send();\n\n}).then(function(){\n\t// All done!\n});\n```\n\n*Note: See the [can-zone/register docs](https://github.com/canjs/can-zone/blob/master/docs/register.md) about ensuring can-zone is registered properly.*\n\n## Tasks\n\nJavaScript uses various task queues (and a microtask queue) to run JavaScript in the event loop. See [this article](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/) and [this StackOverflow answer](http://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context) to learn more.\n\nFor can-zone to work we have to override various task-creating functionality, this is the list of what we currently implement:\n\n**Macrotasks**\n\n* setTimeout\n* XMLHttpRequest\n\n**Microtasks**\n\n* requestAnimationFrame\n* Promise\n* process.nextTick\n\n## API\n\n- <code>[__can-zone__ function](#can-zone-function)</code>\n  - <code>[new Zone()](#new-zone)</code>\n  - <code>[new Zone(zoneSpec)](#new-zonezonespec)</code>\n    - _static_\n      - <code>[Zone.waitFor(fn)](#zonewaitforfn)</code>\n      - <code>[Zone.current](#zonecurrent)</code>\n      - <code>[Zone.ignore(fn)](#zoneignorefn)</code>\n      - <code>[Zone.error(err)](#zoneerrorerr)</code>\n    - _prototype_\n      - <code>[zone.run(fn)](#zonerunfn)</code>\n      - <code>[zone.data](#zonedata)</code>\n      - <code>[zone.addWait()](#zoneaddwait)</code>\n      - <code>[zone.removeWait()](#zoneremovewait)</code>\n    - _types_\n      - <code>[ZoneSpec Object](#zonespec-object)</code>\n      - <code>[makeZoneSpec function([data](#zonedata))](#makezonespec-functiondatazonedata)</code>\n    - _modules_\n      - <code>[__can-zone/register__ function](#can-zoneregister-function)</code>\n    - _plugins_\n      - <code>[__can-zone/timeout__ function(ms)](#can-zonetimeout-functionms)</code>\n        - <code>[timeout(ms)](#timeoutms)</code>\n          - <code>[TimeoutError Error](#timeouterror-error)</code>\n      - <code>[__can-zone/debug__ function](#can-zonedebug-function)</code>\n        - <code>[debug(ms)](#debugms)</code>\n        - <code>[debug(timeoutZone)](#debugtimeoutzone)</code>\n          - <code>[DebugInfo Array\\<Object\\>](#debuginfo-arrayobject)</code>\n\n## <code>__can-zone__ function</code>\n\n\n\n### <code>new Zone()</code>\n\n\nCreates a new Zone with no additional overrides. Can then call [zone.run](#zonerunfn) to call a function within the Zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar zone = new Zone();\n\nzone.run(function(){\n\n\treturn \"hello world\";\n\n}).then(function(data){\n\tdata.result // -> \"hello world\"\n});\n```\n\n\n### <code>new Zone(zoneSpec)</code>\n\n\nCreate a new Zone using the provided [ZoneSpec](#zonespec-object) to configure the Zone. The following examples configures a Zone that will time out after 5 seconds.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar timeoutSpec = function(){\n\tvar timeoutId;\n\n\treturn {\n\t\tcreated: function(){\n\t\t\ttimeoutId = setTimeout(function(){\n\t\t\t\tZone.error(new Error(\"This took too long!\"));\n\t\t\t}, 5000);\n\t\t},\n\t\tended: function(){\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t};\n};\n\nvar zone = new Zone(timeoutSpec);\n```\n\n\n1. __zoneSpec__ <code>{[ZoneSpec](#zonespec-object)|[makeZoneSpec](#makezonespec-functiondatazonedata)([data](#zonedata))}</code>:\n  A [ZoneSpec](#zonespec-object) object or a [function that returns](#makezonespec-functiondatazonedata) a ZoneSpec object.\n  \n  These two are equivalent:\n  \n  ```js\n  new Zone({\n  \tcreated: function(){\n  \t\t\n  \t}\n  });\n  \n  new Zone(function(){\n  \treturn {\n  \t\tcreated: function(){\n  \n  \t\t}\n  \t};\n  });\n  ```\n  \n  The latter form is useful so that you have a closure specific to that [Zone](#new-zone).\n  \n\n#### <code>Zone.waitFor(fn)</code>\n\n\n**Zone.waitFor** is a function that creates a callback that can be used with any async functionality. Calling Zone.waitFor registers a wait with the currently running request and returns a function that, when called, will decrement the wait count.\n\nThis is useful if there is async functionality other than what [we implement](#tasks). You might be using a library that has C++ bindings and doesn't go through the normal JavaScript async APIs.\n\n```js\nvar Zone = require(\"can-zone\");\nvar fs = require(\"fs\");\n\nfs.readFile(\"data.json\", \"utf8\", Zone.waitFor(function(){\n\t// We waited on this!\n}));\n```\n\n\n1. __fn__ <code>{function}</code>:\n  \n  \n\n#### <code>Zone.current</code>\n\n\nRepresents the currently running [zone](#new-zone). If the code using **Zone.current** is not running within a zone the value will be undefined.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar myZone = new Zone();\n\nmyZone.run(function(){\n\n\tZone.current === myZone;\n\n});\n```\n\n\n#### <code>Zone.ignore(fn)</code>\n\n\nCreates a function that, when called, will not track any calls. This might be needed if you are calling code that does unusual things, like using setTimeout recursively indefinitely.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\tfunction recursive(){\n\t\tsetTimeout(function(){\n\t\t\trecursive();\n\t\t}, 20000);\n\t}\n\n\tvar fn = Zone.ignore(recursive);\n\n\t// This call will not be waited on.\n\tfn();\n});\n```\n\n\n1. __fn__ <code>{function}</code>:\n  A function that contains calls to asynchronous functions that are needing to be ignored.\n  \n\n- __returns__ <code>{function}</code>:\n  A function in which calls to [addWait](#zoneaddwait) and [removeWait](#zoneremovewait) will be ignored, preventing the Zone's promise from remaining unresolved while asynchronous activity continues within.\n  \n\n#### <code>Zone.error(err)</code>\n\n\nAllows you to add an error to the currently running zone.\n\n```js\nvar Zone = require(\"can-zone\");\n\nnew Zone().run(function(){\n\n\tsetTimeout(function(){\n\t\tZone.error(new Error(\"oh no\"));\n\t}, 100);\n\n}).then(null, function(error){\n\terror; // -> {message: \"oh no\"}\n});\n```\n\n\n1. __err__ <code>{Error}</code>:\n  \n  \n\n#### <code>zone.run(fn)</code>\n\n\nRuns a function within a [Zone](#new-zone). Calling run will set the Zone's internal Promise which will only resolve once all asynchronous calls within `fn` are complete.\n\n\n1. __fn__ <code>{function}</code>:\n  Any function which needs to run within the Zone. The function will be executed immediately.\n  \n\n- __returns__ <code>{Promise\\<[data](#zonedata)\\>}</code>:\n  Returns a promise that will resolve with the Zone's [data](#zonedata) object.\n  \n  ```js\n  var zone = new Zone();\n  \n  zone.run(function(){\n  \n  \tsetTimeout(function(){\n  \t\tzone.data.foo = \"bar\";\n  \t});\n  \n  }).then(function(data){\n  \tdata.foo // -> \"bar\"\n  });\n  ```\n  \n\n#### <code>zone.data</code>\n\n\nYou might want to get data back from can-zone, for example if you are using the library to track asynchronous rendering requests. Each zone contains a **data** object which can be used to store artibitrary values.\n\n```js\nvar Zone = require(\"can-zone\");\n\nvar xhr = new XMLHttpRequest();\nxhr.open(\"GET\", \"http://example.com\");\nxhr.onload = function(){\n\t// Save this data for later\n\tZone.current.data.xhr = xhr.responseText;\n};\nxhr.send();\n```\n\n\n\n#### <code>zone.addWait()</code>\n\n\nAdds a wait to the [Zone](#new-zone). Adding a wait will delay the Zone's Promise from resolving (the promise created by calling [zone.run](#zonerunfn)) by incrementing its internal counter.\n\nUsually a corresponding [removeWait](#zoneremovewait) will be called to decrement the counter.\n\n```js\nnew Zone().run(function(){\n\n\tvar zone = Zone.current;\n\n\tzone.addWait(); // counter at 1\n\tzone.removeWait(); // counter at 0, Promise resolves\n\n}).then(function(){\n\n});\n```\n\n\n#### <code>zone.removeWait()</code>\n\n\nDecrements the [Zone's](#new-zone) internal counter that is used to decide when its [run Promise](#zonerunfn) will resolve.\n\nUsually used in conjuction with [addWait](#zoneaddwait). Most of the time you'll want to use [waitFor](#zonewaitforfn), but in some cases where a callback is not enough to know waiting is complete, using addWait/removeWait gives you finer grained control.\n\n```js\nvar zone = new Zone();\n\nvar obj = new SomeObject();\n\n// This is only done when the event.status is 3\nobj.onprogress = function(ev){\n\tif(ev.status === 3) {\n\t\tzone.removeWait();\n\t}\n};\n\nzone.addWait();\n```\n\n#### ZoneSpec `{Object}`\n\n A ZoneSpec is the way you tap into the lifecycle hooks of a [Zone](#new-zone). The hooks are described below.\n\nUsing these hooks you can do things like create timers and override global variables that will change the *shape* of code that runs within the Zone.\n\n\n\n\n##### <code>Object</code>\n\n- __created__ <code>{function}</code>:\n  \n  \n  Called when the zone is first created, after all ZoneSpecs have been parsed. this is useful if you need to do setup behavior that covers the entire zone lifecycle.\n  \n  ```js\n  new Zone({\n  \tcreated: function(){\n  \t\t// Called as soon as `new Zone` is called\n  \t}\n  });\n  ```\n  \n- __beforeRun__ <code>{function}</code>:\n  \n  \n  Called immediately before the **Zone.prototype.run** function is called.\n  \n  ```js\n  var zone = new Zone({\n  \tbeforeRun: function(){\n  \t\t// Setup that needs to happen immediately before running\n  \t\t// the zone function\n  \t}\n  });\n  \n  zone.run(function() { ... });\n  ```\n  \n- __beforeTask__ <code>{function}</code>:\n  \n  \n  Called before each Task is called. Use this to override any globals you want to exist during the execution of the task:\n  \n  ```js\n  new Zone({\n  \tbeforeTask: function(){\n  \t\twindow.setTimeout = mySpecialSetTimeout;\n  \t}\n  });\n  ```\n  \n- __ended__ <code>{function}</code>:\n  \n  \n  Called when the Zone has ended and is about to exit (it's Promise will resolve).\n  \n- __hooks__ <code>{Array\\<string\\>}</code>:\n  \n  \n  **hooks** allows you to specify custom hooks that your plugin calls. This is mostly to communicate between plugins that inherit each other.\n  \n  ```js\n  var barZone = {\n  \tcreated: function(){\n  \t\tthis.execHook(\"beforeBar\");\n  \t},\n  \n  \thooks: [\"beforeBar\"]\n  };\n  \n  var fooZone = {\n  \tbeforeBar: function(){\n  \t\t// Called!\n  \t},\n  \tplugins: [barZone]\n  };\n  \n  new Zone({\n  \tplugins: [fooZone]\n  });\n  \n  zone.run(function() { ... });\n  ```\n  \n- __plugins__ <code>{Array\\<[ZoneSpec](#zonespec-object)|[makeZoneSpec](#makezonespec-functiondatazonedata)([data](#zonedata))\\>}</code>:\n  \n  \n  Allows specifying nested [ZoneSpecs](#zonespec-object) that the current depends on. This allows creating rich plugins that depend on other plugins (ZoneSpecs). You can imagine having a bunch of tiny plugins that do one thing and then composing them together into one meta-plugin that is more end-user friendly.\n  \n  Similar to the [Zone](#new-zone) constructor you can either specify [ZoneSpec](#zonespec-object) objects or functions that return ZoneSpec objects. The former gives you a closure specific to the Zone, which is often needed for variables. These two forms are equivalent:\n  \n  ```js\n  var specOne = {\n  \tcreated: function(){\n  \n  \t}\n  };\n  \n  var specTwo = function(){\n  \treturn {\n  \t\tcreated: function(){\n  \n  \t\t}\n  \t}\n  };\n  \n  var zone = new Zone({\n  \tplugins: [ specOne, specTwo ]\n  });\n  ```\n  \n#### makeZoneSpec `{function([data](#zonedata))}`\n\n\nA function that returns a [ZoneSpec](#zonespec-object) object. This can be used any place where a [ZoneSpec](#zonespec-object) is accepted.\n\n\n\n##### <code>function([data](#zonedata))</code>\n\n\n1. __data__ <code>{[data](#zonedata)}</code>:\n  The [Zone's](#new-zone) data object, useful when you want to append data to the Zone.\n  \n  This examples wraps [document.createElement](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) to keep count of how many elements are created, and appends the count to [data](#zonedata) when the Zone ends.\n  \n  ```js\n  var mySpec = function(data){\n  \tvar realCreateElement,\n  \t\tcount = 0;\n  \n  \treturn {\n  \t\tbeforeTask: function(){\n  \t\t\trealCreateElement = document.createElement;\n  \t\t\tdocument.createElement = function(){\n  \t\t\t\tcount++;\n  \t\t\t\treturn realCreateElement.apply(this, arguments);\n  \t\t\t};\n  \t\t},\n  \t\tafterTask: function(){\n  \t\t\tdocument.createElement = realCreateElement;\n  \t\t},\n  \t\tended: function(){\n  \t\t\tdata.elementsCreated = count;\n  \t\t}\n  \t};\n  };\n  \n  var zone = new Zone(mySpec);\n  \n  zone.run(function(){\n  \t// Do stuff here\n  })\n  .then(function(data){\n  \tdata.elementsCreated; // -> 5\n  });\n  ```\n  \n\n- __returns__ <code>{[ZoneSpec](#zonespec-object)}</code>:\n  A [ZoneSpec](#zonespec-object)\n  \n#### can-zone/register `{function}`\n\n \nIn order to do it's magic, [can-zone](#new-zone) has to register handlers for all of the common JavaScript async operations. If you have code (or a dependency with this code) that does:\n\n```js\nvar st = setTimeout;\n```\n\nAnd this module loads before can-zone, any time `st` is used we won't be able to track that within the Zone.\n\nTo work around this, **can-zone/register** is used as a script that you run before any other modules.\n\n### In Node\n\n```js\nrequire(\"can-zone/register\");\n```\n\nAt the top of your entry-point script.\n\n### In the Browser\n\nYou can either add a script tag above all others:\n\n```js\n<script src=\"node_modules/can-zone/register.js\"></script>\n```\n\nOr, if you're using a module loader / bundler, configure it so that can-zone/register is placed above all others in the bundle.\n\n\n\n\n##### <code>function()</code>\n\n\n- __returns__ <code>{undefined}</code>:\n  \n\n#### <code>__can-zone/timeout__ function(ms)</code>\n\n\n\n##### <code>timeout(ms)</code>\n\n\nCreates a [ZoneSpec](#zonespec-object) that you can use as a plugin for your [Zone](#new-zone) in order to timeout after a certain length of time (as `ms`).\n\nIf the Zone times out it's [run promise](#zonerunfn) will be rejected with a [TimeoutError](#timeouterror-error), a special error that also includes the number of milliseconds waited before timing out.\n\n```js\nvar Zone = require(\"can-zone\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar zone = new Zone({\n\tplugins: [ timeout(5000) ]\n});\n\nzone.run(function(){\n\tsetTimeout(function(){\n\n\t}, 10000); // waiting over 5 sec\n})\n.catch(function(err){\n\t// Called because we exceeded the timeout.\n});\n```\n\n\n1. __ms__ <code>{Number}</code>:\n  The number of milliseconds to wait before timing out the [Zone](#new-zone).\n  \n\n- __returns__ <code>{[ZoneSpec](#zonespec-object)}</code>:\n  A ZoneSpec that can be passed as a plugin.\n  \n###### TimeoutError `{Error}`\n\nA special type of Error that also includes the number of milliseconds that were waited before timing out. \nThe error object is included with the timeout module:\n\n```js\nvar timeout = require(\"can-zone/timeout\");\n\nvar TimeoutError = timeout.TimeoutError;\n// Maybe use this to check `instanceof`.\n```\n\n\n\n\n####### <code>Error</code>\n\n- __timeout__ <code>{Number}</code>:\n  Specifies the timeout that was exceeded.\n  \n\n#### <code>__can-zone/debug__ function</code>\n\n\n\n##### <code>debug(ms)</code>\n\n\nCreates a new [ZoneSpec](#zonespec-object) that can be provided to your Zone, timing out in `ms` (milliseconds).\n\n```js\nvar Zone = require(\"can-zone\");\nvar debug = require(\"can-zone/debug\");\n\nvar zone = new Zone({\n\tplugins: [debug(5000)]\n})\n.catch(function(err){\n\tvar info = zone.data.debugInfo;\n});\n```\n\nSee the [DebugInfo](#debuginfo-arrayobject) type for a list of properties \n\n\n1. __ms__ <code>{Number}</code>:\n  The timeout, in milliseconds, before the [Zone](#new-zone) will be rejected and debug information attached to the [zone's data](#zonedata) object.\n  \n\n##### <code>debug(timeoutZone)</code>\n\n\nLike the previous signature, but directly pass it a [timeout ZoneSpec](#timeoutms) object that you create yourself.\n\n```js\nvar debug = require(\"can-zone/debug\");\nvar timeout = require(\"can-zone/timeout\");\n\nvar timeoutZone = timeout(5000);\nvar debugZone = debug(timeoutZone):\n\n...\n```\n\n\n1. __timeoutZone__ <code>{[can-zone/timeout](#timeoutms)}</code>:\n  A [ZoneSpec](#zonespec-object) created using the timeout plugin.\n  \n###### DebugInfo `{Array\\<Object\\>}`\n\nAn array of objects containing information useful for debugging. Gives you the name of the **task** that failed to complete and a **stack** trace of where the error occured. \nEach object has a shape of:\n\n```js\n{\n\t\"task\": \"setTimeout\",\n\t\"stack\": Error ....\"\n}\n```\n\n\n\n\n####### <code>Array\\<Object\\></code>\n\n- __task__ <code>{String}</code>:\n  An identifier of the task that failed to complete. This can be any of the [asynchronous tasks](https://github.com/canjs/can-zone#tasks) supported by can-zone like `setTimeout` or `Promise`.\n  \n  \n- __stack__ <code>{String}</code>:\n  A stack trace taken as a snapshot when the task was called. This allows you t see the source of the call to help debug why the task never completed.\n  \n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/canjs/can-zone.git"
  },
  "scripts": {
    "build": "node scripts/build.js",
    "document": "bit-docs",
    "postversion": "git push --tags && git checkout master && git branch -D release && git push",
    "preversion": "npm run build",
    "release:major": "npm version major && npm publish",
    "release:minor": "npm version minor && npm publish",
    "release:patch": "npm version patch && npm publish",
    "test": "npm run test:node && npm run test:browser",
    "test:browser": "testee test/test.html test/register.html --browsers firefox --reporter Spec",
    "test:node": "mocha test/test.js && mocha test/test_register_node.js",
    "version": "git commit -am \"Update dist for release\" && git checkout -b release && git add -f dist/"
  },
  "system": {
    "npmDependencies": [
      "steal-mocha",
      "mocha",
      "chai"
    ],
    "map": {
      "./assert": "chai/chai"
    },
    "meta": {
      "chai/chai": {
        "format": "global",
        "exports": "chai.assert"
      }
    }
  },
  "version": "0.5.8"
}
